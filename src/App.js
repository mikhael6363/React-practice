import { useState } from 'react';
import './App.css';
import StopWatch from './components/StopWatch';

function App(props) {
  const [isVisible, setIsVisible] = useState(true);
  return (
    <>
      <button onClick={() => setIsVisible(!isVisible)}>Change</button>
      {isVisible ? <StopWatch /> : null}
    </>
  );
}

export default App;

/*
  Жизненный цикл Копонента:
  (детально можно посмотреть в диаграмме)

  1. Монтирование (рождение) => componentDidMount
  2. Обновление (жизнь) => componentDidUpdate
  3. Размонтирование (смерть) => componentWillUnmount
_______________________________________________________________________________

  Порядок действий на примере нашего секундомера:
  1- constructor
  2- render
  3- componentDidMount -> содержит this.start() -> к-й сожержит setState
  4- render (постоянно обновляет состояние)
  5- componentDidUpdate (и по кругу 4-5 пункт) render, didUpdate...
_______________________________________________________________________________

  Что вызывает обновление состояния в React?
  a. Новые Props
  b. setState()
  c. forceUpdate() - плохая практика
_______________________________________________________________________________

  Методы жизненных циклов:
  1) "componentDidMount()"
    => СРАБАТЫВАЕТ ПОСЛЕ ПЕРВОГО РЕНДЕРА
    Вызывается сразу после монтирования (то есть, вставки компонента в DOM).

  2) "componentDidUpdate(prevProps, prevState, snapshot)"
    => СРАБАТЫВАЕТ ПОСЛЕ КАЖДОГО РЕНДЕРА, ИСКЛЮЧАЯ ПЕРВЫЙ
    Вызывается сразу после обновления. Не вызывается при первом рендере. Метод позволяет работать с DOM при обновлении компонента.

  3) "componentWillUnmount()"
    => РАЗМОНТИРУЕТ (ОСТАНАВЛИВАЕТ) КОМПОНЕНТ
    Вызывается непосредственно перед размонтированием и удалением компонента. В этом методе выполняется необходимый сброс: отмена таймеров, сетевых запросов и подписок, созданных в componentDidMount().


    render() не сам отрисовывает вьюху, а возвращает Виртуальный DOM. Который в последствии сравнивается React'ом с настоящим DOM (согласование).


_______________________________________________________________________________

  Заметка!

  Обычно мы юзаем this.setState({ obj }) <- внутри которого объект.

  Но когда наше состояние зависит от прошлого, мы должны использовать функцию, а не объект
    => this.setState((state,props)=>{})

  В примере
  tick = () => {
    this.setState((state, props) => {
      const { time } = state;
      const timeCopy = new Date(time.getTime());
      timeCopy.setSeconds(time.getSeconds() + 1);
      return {
        time: timeCopy,
      };
    });
  };

  Мы из функции - возвращаем новый объект состояния.



_______________________________________________________________________________





_______________________________________________________________________________





_______________________________________________________________________________
*/
